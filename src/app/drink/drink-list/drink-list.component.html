<div *ngIf="(filtersData$ | async) as filtersData" class="card d-flex flex-row my-5">
  <div class="sidebar">
    <!-- tkzw. async pipe, świetna sprawa jeśli chodzi o asynchroniczne dane (automatycznie jest robiony unsubscribe przy ngOnDestroy), można było też wrzucić do async pipe drinks ale i tak musimy sterować nimi z poziomu komponentu także i ten sposób z subscribe jest dobry - ważne wtedy żeby anulować subskrypcję -->

    <!-- sidenote: przy async pipe robimy if zazwyczaj (jeszcze się nie spotkałem żeby async pipe był poza ifem)
    i generalnie UI Ci się nie wyswietli póki API czegoś nie zwróci albo nie złapie catchErrora. To jest powszechnie stosowane rozwiązanie.
    Profesjonalnie byłoby zrobić jakis spinner który by się wyświetlał podczas ładowania danych.
    Można go zrobić i wyświetlać na bazie asynchronicznej flagi "isLoading" albo cos takiego. Angular material ma gotowy spinner.
    mat-spinner. -->

    <div class="brand-list">
      <mat-form-field>
        <mat-select placeholder="Marki" multiple>
          <mat-option *ngFor="let brand of filtersData.brands">{{brand}}</mat-option>
        </mat-select>
      </mat-form-field>
    </div>


    <div class="sugar-slider">
      <h3>Cukier</h3>
      <mat-slider discrete min="0" max="75" step="0.5">
        <input value="0" matSliderStartThumb>
        <input value="75" matSliderEndThumb>
      </mat-slider>
    </div>

    <div class="flavour-list">
      <mat-form-field>
        <mat-select placeholder="Smaki" multiple>
          <mat-option *ngFor="let flavour of filtersData.flavours">{{flavour}}</mat-option>
        </mat-select>
      </mat-form-field>
    </div>

  </div>
  <div class="card-body">
    <ul class="text-center list-inline py-3" id="sort-panel">
      <li class="list-inline-item" id="add">
        <a routerLink="/addDrink" class="btn btn-info">+</a>
      </li>
      <li class="list-inline-item">
        <select [compareWith]="compareObjects" id="sort" class="form-select" [ngModel]="selectedSortingOption"
          (ngModelChange)="onSortChanged($event)">
          <option selected>Sortuj</option>
          <!-- można się pokusić jeszcze o utworzenie jakiejs tablicy zamiast zahardkodowanych
          options, ale to juz tobie zostawiam :D -->
          <option [ngValue]="{sortBy: 'brand', sortOrder: 'ASC'}"> Marka A-Z</option>
          <option [ngValue]="{sortBy: 'brand', sortOrder: 'DESC'}"> Marka Z-A</option>
          <option [ngValue]="{sortBy: 'name', sortOrder: 'ASC'}"> Nazwa A-Z</option>
          <option [ngValue]="{sortBy: 'name', sortOrder: 'DESC'}"> Nazwa Z-A</option>
          <option [ngValue]="{sortBy: 'sugar', sortOrder: 'ASC'}"> Cukier - od min</option>
          <option [ngValue]="{sortBy: 'sugar', sortOrder: 'DESC'}"> Cukier - od max</option>
          <option [ngValue]="{sortBy: 'flavour', sortOrder: 'ASC'}"> Smak A-Z</option>
          <option [ngValue]="{sortBy: 'flavour', sortOrder: 'DESC'}"> Smak Z-A</option>
        </select>
      </li>
    </ul>
    <table class="table table-striped table-dark">
      <thead class="thead-dark">
        <tr>
          <th scope="col">#</th>
          <th scope="col">Marka</th>
          <th scope="col">Nazwa</th>
          <th scope="col">Cukier</th>
          <th scope="col">Smak</th>
        </tr>
      </thead>
      <tbody>
        <tr *ngFor="let drink of drinks">
          <td>{{ drink.id }} </td>
          <td>{{ drink.brand }} </td>
          <td>{{ drink.name }} </td>
          <td>{{ drink.sugar }} </td>
          <td>{{ drink.flavour }} </td>
        </tr>
      </tbody>
    </table>
    <router-outlet></router-outlet>
  </div>
</div>